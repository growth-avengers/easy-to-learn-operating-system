# 스케줄링의 개요 
## 01 스케줄링의 개요 
CPU 스케줄러, 프로세서 스케줄러
</br>
스케줄링: 여러 프로세스의 상황을 고려하여 CPU와 시스템 자원을 어떻게 배정할지 결정하는 일을 하는 것 
</br>
</br>
CPU 스케줄링
> 작업 단계<br>
> <img width="476" alt="Screen Shot 2023-05-22 at 2 14 00 PM" src="https://github.com/Sunjung-Dev/TIL-/assets/76513889/0633ec8c-85d4-4d98-b635-30fb08a50e4b">
> - 규모에 따라: 고수준 스케줄링, 중간 수준 스케줄링, 저수준 스케줄링 
>   - 고수준 스케줄링, 장기 스케줄링, 작업 스케줄링, 승인 스케줄링 
>       - 시스템 내의 전체 작업 수를 조절하는 것 
>           - 작업: 운영체제에서 다루는 가장 큰 단위, 1개 또는 여러 개의 프로세스로 이루어짐 
>       - 어떤 작업을 시스템이 받아들일지 또는 거부할지 결정함 -> 승인 스케줄링이라고도 함 
>       - <span style="color:blue">멀티프로그래밍 정도: </span>: 시스템의 전체 프로세스 수를 전체 시스템의 부하를 고려하여 작업을 시작할지 말지 정하게 됨 
>       - 메인프레임과 같은 큰 시스템에서 규모가 큰 일괄 작업을 처리할 때 사용함 
>   - 저수준 스케줄링, 단기 스케줄링 
>       - 어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 대기 상태로 보낼지 등을 결정하는 일 
>       - 준비 상태에 있는 프로세스 중 하나를 골라 실행 상태로 보내고, 실행 상태에 있는 프로세스를 대기 상태로 보내고, 대기 상태의 프로세스를 준비 상태로 보냄 
>       - 시스템 부하를 고려할때
>   - 중간 수준 스케줄링
>       - 중지와 활성화로 전체 시스템의 활성화된 프로세스 수를 조절하여 과부하를 막음 
>       - 보류상태: 일부 프로세스를 중지 상태로 옮김으로써 나머지 프로세스가 원만하게 작동하도록 지원 
>       - 저수준 스케줄링이 원만하게 이루어지도록 완춘하는 역할 
</br>

스케줄링의 목적 
> 특정 프로세스가 시스템 자원을 독점하는 것을 막음 -> 우선순위를 배정해야 함 
> 공평성, 효율성, 안정성, 확장성, 반응시간 보장, 무한 연기 방지 
---------

<br>

## 02 스케줄링 시 고려 사항 
1.선점형 스케줄링과 비선점형 스케줄링<br> 
> 선점형 스케줄링: 어떤 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는 스케줄링 방식 
>   - 운영체제가 필요하다고 판단하면 실행 상태에 있는 프로세스의 작업을 중단, 새로운 작업 시작 
>   - <span style="color: red"> 인터럽트 처리</span>: CPU가 현재 실행 중인 작업을 중단하고 커널을 깨워서 처리함 
>   - 단점
>       - <span style="color: blue">문맥교환</span>, 부가적인 작업으로 인해 낭비가 생긴다는 단점 
>       - 시분할 시스템, 대화형 시스템, 저수준 스케줄러
 
> 비선점형 스케줄링: 어떤 프로세스가 실행 상태에 들어가 CPU를 사용하면 그 프로세스가 종료되거나 자발적으로 대기 상태에 들어가기 전까지는 계속 실행 
>   - 작업량이 적고 문맥 교환에 의한 낭비도 적음 
>   - 단점
>       - CPU 사용 시간이 긴 프로세스 때문에 CPU 사용 시간이 짜랍은 여러 프로세스가 오랫동안 기다리게 되어 전체 시스템의 처리율이 떨어짐.
>       -  일괄 작업 시스템 
</br>
</br>

선점형 + 비선점형 스케줄링 -> 비선점형 프로세스의 중요도를 매우 낮게 설정하여 선점형 프로세스에 영향을 덜 미치도록 함 

</br>

프로세스 우선순위 
> 프로세스의 우선순위가 없다는 것은 모든 프로세스의 중요도가 같다는 의미 
> - 우선순위가 없는 프로세스는 준비 상태에 한 줄로 서서 순차적으로 실행 -> 준비 상태의 큐가 하나인 것 
> - CPU 스케줄러는 우선순위를 사용 
>   - 중요도갇 다르다는 의미 
> - 우선순위: 커널 프로세스 > 일반 프로세스 => 더 빨리 자주 실행된다는 의미 
>   - 우선순위가 높을수록 CPU를 먼저 더, 오래 차지함 

</br>

CPU 집중 프로세스와 입출력 집중 프로세스 
> - 준비상태 
>   - CPU를 할당받기 위해 기다리는 상태
> - 실행상태, 대기상태
>   - 실제 작업이 일어남 
>   - 실행상태: CPU를 사용하여 작업 (CPU 버스트)
>   - 대기상태: 입출력을 요청하여 완료되기까지 기다림 (입출력 버스트)

> CPU 집중 프로세스 
>   - CPU를 많이 사용하는 프로세스, CPU 버스트가 많음 
</br>

> 입출력 집중 프로세스 
>   - 저장장치에서 데이터를 복사하는 일과 같이 입출력을 많이 사용하는 프로세스,
</br>

=> 입출력 집중 프로세스를 먼저 실행 상태로 옮기는 것이 효율적 => 사이클 훔치기: CPU를 잠깐 사용한 후 대기 상태로 이동하기 때문에 다른 프로세스가 CPU를 사용할 수 있기 때문에 

</br>

전면 프로세스와 후면 프로세스
> 전면 프로세스
>   - 현재 입력과 출력을 사용하는 프로세스 
>   - 사용자와 상호작용이 가능하여 상호작용 프로세스

> 후면 프로세스 
>   - 사용자와 상호작용이 없는 프로세스 
>   - 사용자의 입력 없이 작동, 일괄 작업 프로세스 

=> 우선순위: 전면 프로세스 > 후면 프로세스</br>
- 후면 프로세스는 전면 프로세스보다 CPU를 할당받을 확률이 낮음 


-----
## 03 다중 큐 
준비 상태의 다중 큐 
> 고정 우선순위 방식 
> - 운영체제가 프로세스에 우선순위를 부여하면 프로세스가 끝날 때까지 바뀌지 않는 방식 
> - 시스템의 변화에 대응하기 어려워 작업 효율이 떨어짐 

> 변동 우선순위 방식 
> - 프로세스 생성 시 부여받은 우선순위가 프로세스 작업 중간에 변하는 방식 
> - 시스템의 효율성을 높임 

대기 상태의 다중 큐 
> - 대기 상태에서는 같은 입출력을 요구한 프로세스끼리 모아놔야 함 
> - 같은 장치의 입출력을 기다리는 프로세스의 프로세스 제어 블록은 동일한 입출력 큐에 모여 있음 
> - 준비 상태의 다중 큐 vs 대기 상태의 다중 큐 
>   - 준비 큐: 한 번에 하나의 프로세스를 꺼내 CPU를 할당
>   - 대기 큐: 여러 개의 프로세스 제어 블록을 동시에 꺼내어 준비 상태로 옮김 
>       - 큐에 삽입된 순서대로 처리되지만 안그럴수도 있음 
>   </br>
>   => 입출력이 동시에 끝날 경우 여러 개의 인터럽트가 한꺼번에 처리 
>   </br>
>   => <span style='color:blue'>인터럽트벡터</span> (자료구조)
>       - 동시에 완료된 입출력 정보와 처리 방법이 담겨 잇음 
>   

----
## 04 스케줄링 알고리즘 
스케줄링 알고리즘의 선택 기준 
> - CPU 사용률, 처리량, 대기 시간, 응답 시간, 반환 시간 
> - 평균 대기 시간을 비교 
<br>

FCFS 스케줄링 
> 동작 방식
> - 비선점형 방식 
> - 선입선출 스케줄링 
> - 모든 프로세스의 우선순위가 동일함 
> <br>

> 성능 
> - 평균 대기 시간 = sum(작업 시작 시간) / 프로세스의 수 
><br>

> 평가 
> - 처리 시간이 긴 프로세스가 CPU를 차지하면 효율성이 떨어짐 
> - 작업 중인 프로세스가 입출력 작업을 요청하는 경우 CPU가 작업하지 않고 쉬는 시간이 많아저 작업 효율 떨어짐 

<br>

SJF 스케줄링
> 동작 방식
> - 비선점형 방식
> - 최단 작업 우선 스케줄링

> 평가 
> - 효율성 굳 
> - 평균 대기 시간이 줄어듬 
> 1. 운영체제가 프로세스의 종료 시간을 정확하게 예측하기 어렵다 
>    - 프로세스는 사용자와 빈번하게 상호작용하기 때문에 프로그램 종료 시간 파악이 어려움 
>       - 프로세스가 자신의 작업 시간을 운영체제에 알려줘서 해결 
> 2. SJF 알고리즘은 공평성에 위배됨 
>       -   아사현상, 무한 봉쇄 현상: 작업시간이 길다는 이유로 계속 밀림 
>           - aging(에이징)으로 해결 

HRN 스케줄링
> 동작 방식
> - 비선점형 알고리즘 
> - SJF의 아사현상을 해결하기 위해서 
> - 최고 응답률 우선 스케줄링
> - CPU 사용 시간을 고려하여 스케줄링하는 방식 
> - 우선순위 = (대기시간 + CPU 사용 시간) / CPU 사용 시간 

> 성능 
> - 스케줄링 방식 + 에이징 

> 평가 
> - 대기 시간이 긴 프로세스의 우선순위를 높임으로써 CPU를 할당받을 확률을 높임 
> - 공평성이 위배되어 많이 사용되지는 않음 

라운드 로빈 스케줄링
> 동작 방식 
> - 한 프로세스가 할당받은 시간 동안 작업을 하다가 완료하지 못하면 준비 큐의 맨 뒤로 가서 자기 차례를 기다리는 방식 
> - 선점형 알고리즘
> - 최대 시간, 타임 슬라이스가 있음 
> - 자신에게 주어진 타임 슬라이스 동안만 작업할 수 있음
> - 큐의 뒤쪽에 다시 삽입 

> 성능
> - 콘보이 효과: 프로세스가 CPU를 일정 시간 동안 사용한 후 다른 프로세스에 넘겨주어야 하므로 앞의 긴 작업을 무작정 기다리는 콘보이 효과가 줄어듬 

> 평가 
> - FCFS 스케줄링의 평균 대기 시간 + 문맥 교환 시간 

SRT 우선 스케줄링 
> 동작 방식 
> - SJF 스케줄링 + 라운드 로빈 스케줄링 
> - 최소 잔류 시간 우선 스케줄링 
> - SJF 스케줄링의 선점형 버전 
> - 남은 작업 시간이 적은 프로세스에 CPU를 먼저 할당 

> 평가 
> - 현재 실행 중인 프로세스, 큐에 있는 프로세스의 남은 시간을 주기적으로 체크해야 함 
> - 문맥교환 시간 필요 
> - 운영체제가 프로세스 종료 시간을 예측하기 어려움 
> - 아사 현상이 일어남 

우선순위 크제룰링
> 동작방식과 성능 
> - 비선점형, 선점형 모두 구현 가능 
> - 고정 우선순위 알고리즘: 종료될 떄까지 우선순위 고정 
>   - 계속 변하는 시스템 상황을 반영하지 못해 효율성 떨어짐
> - 변동 우선순위 알고리즘: 일정 시간마다 변하는 우선순위를 새로 계산
>   - 시스템 복잡, 시스템 상황을 반영하여 효율적인 운영 가능 

> 평가 
> - 우선순위가 높은 프로세스 할당 -> 공평성 위배, 아사 현상
> - 오버헤드 발생 -> 효율성 떨어짐 

다단계 큐 스케줄링
> - 준비 큐를 여러개 사용 
> - 선점형 방식 
> - 우선순위에 따른 타임 슬라이스 조절 
> - 하위 큐 프로세스 작업 불가능 

다단계 피드백 큐 스케줄링
 > - 프로세스에게 한번씩 할당, 실행될때마다 우선순위 낮춤
 > - 커널 프로세스가 일반 프로세스의 큐에 삽입되지는 않음 
 > - 우선순위에 따라 타임 슬라이스의 크기가 다름
 > - 마지막 큐에 있는 프로세스는 무한대의 타임 슬라이스를 얻음 
 > - 실행상태에 들어가면 끝까지 작업 
 > - FCFS 스케줄링 방식처럼 동작 

 ---
 ## 05 인터럽트 처리 
 인터럽트 
 > 이벤트 드리븐: 주기적으로 확인하여 실행되면 프로세스에 알려줌 
 > 폴링: 운영체제가 주기적으로 입출력장치를 직접 확인 
 > 인터럽트: 입출력이 완료되면 이벤트를 발생시켜 알리게 됨 

 동기적 인터럽트 vs 비동기적 인터럽트 
 > 동기적 인터럽트 
 > - 프로그램의 문제 
 > - ctrl + c 
 > - 입출력장치
 > - 산술 연산 
 > <br>
 >
 > 비동기적 인터럽트
 > - 하드웨어 오류 

 인터럽트 처리 과정
> 인터럽트 번호, 함수

인터럽트와 이중모드 
> 이중모드: 운영체제가 두 모드를 전환하며 일 처리를 하는 것 
>   - 자원을 보호하기 위해 사용하는 기법 
>   - 커널은 시스템 호출을 통해서만 자원에 접근하도록 제한함 
>   - 사용자 프로세스가 커널 모드에서 실행되지 못하게 함 
> <br>
> 
> 사용자가 커너 모드로 진입하는 경우 
>   1. 시스템 호출을 사용한 경우 
>   2. 인터럽트를 발생시킨 경우 

*의논할 내용*
1. 실행상태: 입출력 집중 프로세스, CPU 집중 프로세스 스케줄링할때 어떻게 해야하는지 ?
2. 인터럽트 처리 과정에 대해서 