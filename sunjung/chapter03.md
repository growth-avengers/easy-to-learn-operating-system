# Chapter03 프로세스와 스레드 

## 01 프로세스의 개요 

프로세스의 개념 
> - 프로그램: 어떤 데이터를 사용하여 어떤 작업을 할지 그 절차를 적어놓은 것 
> - 프로세스: '실행한다', 프로그램으로 작성된 작업 절차를 실행에 옮긴다는 의미 
>   - 프로그램 -> 실행 -> 프로세스 

일괄 작업 방식
> - 한 번에 하나의 작업만 처리하는 것

시분할 방식 
> - CPU가 시간을 쪼개어 여러 프로세스에 적당히 배분함으로써 프로세스가 동시에 실행되는 것처럼 느껴짐 

프로그램에서 프로세스로의 전환 
> - 프로세스 제어 블록(PCB): 작업 지시서 
>   - 프로세스 작업 블록가 없으면 프로그램이 프로세스로 전환되지 못함 
>   - 프로세스가 되었다 == 운영체제로부터 프로세스 제어 블록을 받았다 
>   - 구성
>       - 프로세스 구분자: PID 
>       - 메모리 관련 정보: 프로세스 메모리 위치 정보, 프로세스 구분자 
>       - 각종 중간값: 다음에 작업해야 할 코드의 위치가 담긴 레지스터인 프로그램 카운터가 저장됨 -> 작업을 계속 진행될 수 있게 해줌 
>   - 운영체제 영역에 만들어짐 
>   - 프로세스 종료: 해당 프로세스 제어 블록이 폐기 
>   - 프로세스가 된다: 운영체제로부터 프로세스 제어 블록을 얻는다 
>   - 컴퓨터 내에 사용자가 실행한 프로세스만 있는 것이 아님

프로세스 상태(활성상태)
> - 일괄작업시스템: 생성 - 실행 - 완료 끝 ! 
> - 생성상태: 프로세스가 메모리에 올라와 실행 준비를 완료한 상태 -> PCB 생성
> - 준비상태: 생성된 프로세스가 CPU를 얻을 때까지 기다리는 상태
>   - CPU 스케쥴러: 다음에 실행할 프로세스를 선정
>       - 준비상태의 맨 앞에서 기다리고 있는 프로세스 제어블록을 CPU에 전달하여 작업이 이루어짐
>       - <span style="color:blue">큐 구조</span>
> - 실행상태: 실제 작업을 수행하는 상태
>   - 타임아웃: 프로세스가 하나의 타임 슬라이스 동안 작업을 끝내지 못하면 다시 준비 상태로 돌아감 
>   - 클록으로부터의 인터럽트: 일정 시간이 다 되면 클록은 인터럽트를 사용하여 일정 시간이 흘렀다고 CPU에 알려줌 
> - 완료상태: 작업을 마침, PCB가 사라진 상태, 그럼 이때가 프로그램 상태
>   - 메모리에서 삭제, 프로세스 제어 블록 폐기
>   - 코어 덤프: 디버깅하기 위해 강제 종료 직전의 메모리 상태를 저장장치로 옮김
>       - 종료 직전의 메모리 상태를 확인함으로써 오류를 수정할 수 있게 해줌 
> - 대기상태: 입출력을 요구한 프로세스가 입출력이 완료될 때까지 기다리는 상태 
>   - 작업의 효율성을 높이기 위해 입출력을 요청한 프로세스를 실행 상태에 두지 않고 대기 상태로 옮기는 것 
>   - 큐 
>   - 입출력이 완료되면 인터럽트가 발생, 대기 상태에 있는 여러 프로세스 중 해당 인터럽트로 깨어날 프로세스를 찾음 
>   - 인터럽트 때문에 어떤 프로세스는 준비상태로 가는 것 

휴식상태와 보류 상태
> - 휴식상태: 프로세스가 작업을 일시적으로 쉬고 있는 상태
>   - Ctrl + z 
> - 보류상태: 프로세스가 메모리에서 잠시 쫓겨난 상태
>   - 메모리가 꽉 차서 프로세스를 메모리 밖으로 내보낼 때 
>   - 프로그램에 오류가 있어서 실행을 미루어야 할 때 
>   - 바이러스와 같이 악의적인 공격을 하는 프로세스라고 판단될 때 
>   - 매우 긴 주기로 반복되는 프로세스라 메모리 밖으로 쫓아내도 큰 문제가 없을 때 
>   - 입출력을 기다리는 프로세스의 입출력이 계속 지연될 때 
>   - 스왑 영역: 메모리에서 쫓겨난 데이터가 임시로 보관되는 곳 
-----

## 02 프로세스 제어 블록과 문맥 교환 
프로세스 제어 블록
> - 포인터: 프로세스 제어 블록을 연결하여 준비 상태나 대기 상태의 큐를 구현할 때 
> - 프로세스 상태: 활성상태 + 보류 상태 
> - 프로세스 구분자: PID
> - 프로세스 카운터
> - 프로세스 우선순위
> - 각종 레지스터 정보
>   - <span style="color:yellow">왜 중간값으로 저장하게 될까?</span>
> - 메모리 관리 정보 
> - 할당된 자원 정보
> - 계정 정보
> - 부모 프로세스 구분자와 자식 프로세스 구분자 

문맥교환 
> - 문맥교환: 새로운 프로세스를 받아들이는 작업 
>   - 두 프로세스 제어 블록의 내용이 변경됨 
>   - 인터럽트 처리할 때 

타임슬라이스
> - 적당한 크기로 설정하는 것이 중요함, 되도록 작게 설정 

----

## 03 프로세스의 연산 
- fork() 시스템 호출: 실행 중인 프로세스를 복사하는 함수, 실행하던 프로세스는 부모 프로세스, 새로 생긴 프로세스는 자식 프로세스가 됨
> - PID 변함
> - 메모리 관련 정보가 바뀜 
> - PPID, CPID가 바뀜 
> </br>

> 장점
> 1. 프로세스의 생성 속도가 빠름 
> - 기존 메모리에서 복사하기 때문에 
> 2. 추가 작업 없이 자원을 상속할 수 있음. 
> - 부모 프로세스가 사용하던 자원을 추가 작업 없이 자식 프로세스에 상속할 수 있음 
> 3. 시스템 관리를 효율적으로 할 수 있음. 
> - 자식 프로세스를 종료하면 부모 프로세스가 정리할 수 있음. 

> 특징 
> - 부모와 자식 프로세스는 서로 독립적이기 때문에 어떤것이 먼저 출력될지는 알 수 없음. 
<br>

exec()함수: 기존 프로세스를 새로운 프로세스로 전환하는 함수 
> 특징
> - 프로세스는 그대로 둔 채 내용만 바꾸는 시스템 호출
> - 프로세스의 구조를 재활용 
> - 각종 프로세스 구조를 그대로 둔 채 내용만 바꾸어 새로 실행함 
> - 데이터 영역이 새로운 데이터로 채워지고 스택 영역이 리셋됨 
<br>

유닉스 프로세스 계층 구조 
- init(): 전체 프로세스의 출발점이 됨 <br>
> - 자식프로세스로는 login, shell 프로세스 
<br>

프로세스 계층 구조의 장점
> 1. 여러 작업의 동시 처리 
> - login 프로세스: fork()시스템 호출로 동시에 여러 사용자를 처리함 
> - shell 프로세스: login 프로세스가 종료되고 새로운 shell 프로세스가 생성됨 
> <br>
> => 여기서 login 프로세스를 없애고 새로운 shell 프로세스를 만드는 것은 비효율적 
>   - exec()함수 호출: login 프로세스의 구조를 shell 프로세스로 다시 활용
>   - 부모-자식 관계 유지 가능 
>
> 2. 용이한 자원 회수 
> - garbage collection: 프로세스가 작업을 마쳐서 그 프로세스가 사용하던 자원을 회수 
> - 부모 프로세스가 작업을 마쳤을 때 회수함 
<br>

고아 프로세스와 좀비 프로세스 
> - 고아 프로세스: 부모 프로세스가 먼저 종료 
> - 좀비 프로세스: 자식 프로세스가 종료되었는데도 부모 프로세스가 뒤처리를 하지 않음 

---
## 04 스레드 
스레드
> 스레드: CPU 스케줄러가 CPU에 전달하는 일 하나 , CPU의 작업 단위 , 강하게 연결
> 프로세스: 약하게 연결되어 있음

멀티태스크
> 멀티태스크: 서로 독립적, 한 job이 종료되어도 다른 job은 정상적으로 작동함 
>   - 데이터를 주고 받을 때 프로세스간 통신 이용 

멀티스레드
> - 멀티스레드: 동시에 작업을 함
>   - 한 스레드가 종료되면 다른 스레드도 종료됨 
>   - 변수나 파일 등을 공유하고 전역 변수나 함수 호출 등의 방법 

*관련용어*<br>
*-멀티스레드: 여러 개의 스레드로 분할*<br>
*-멀티태스킹:시간을 잘게 난워 배분, 시분할 시스템, 운영체제가 CPU에 전달하는 작업은 스레드*
*-멀티프로세싱:컴퓨터 하나에 CPU가 여러 개 설치되어 동시에 작동하는 것*
*-멀티스레드:*

<br>

멀티스레드
> 배경
>  - fork() 시스템 호출
>   - 코드 영역과 데이터 영역의 일부가 메모리에 중복되어 존재
> - 스레드는 멀티태스킹의 낭비 요소를 제거하기 위해 사용 
>   - 비슷한 일을 하는 2개의 프로세스를 만드는 대신 코드, 데이터 등을 공유하면서 여러 개의 일을 하나의 프로세스 내에서 하는 것 
> - 프로세스의 영역 
>   - 정적인 프로세스 영역: 프로세스가 실행되는 동안 바뀌지 않는 영역 
>   - 동적인 프로세스 영역: 스레드가 작업을 하면서 값이 바뀌거나 새로 만들어지거나 사라지는 영역
<br>

> 장점
> - 자원의 중복을 막음 
> - 여러 스레드를 사용하면 작업의 효율을 높일 수 있음
> - 복잡한 작업을 쉽게 처리
> 1. 응답성 향상
> 2. 자원 공유: 독립적인 스레드를 한 프로세스에서 생성
> 3. 효율성 향상: 불필요한 자원의 중복을 막음 
> 4. 다중 CPU 지원: 다중 CPU가 멀티 스레드를 동시에 처리 -> CPU 사용량 증가, 프로세스의 처리 시간 단축 
<br>

> 단점 
> - 한 스레드에 문제가 생기면 전체 프로세스에 영향 
>   - 프로세스를 여러 개 만드는 방식의 경우 각 프로세스가 독립적이기 대문에 한 프로세스의 문제가 다른 프로세스로 전달되지 않음 
<br>

> 모델
> 커널 스레드, 사용자 스레드
> - 커널 스레드: 커널이 직접 생성하고 관리하는 스레드
> - 사용자 스레드: 라이브러리에 의해 구현된 일반적인 슬데ㅡ

>> 사용자 스레드
>> - 1 to N
>>      - 라이브러리를 사용하여 구현 
>>      - 커널이 지원하는 스케줄링이나 동기화 같은 기능을 대신 구현해 줌 
>>      - 커널의 스레드 하나와 연결됨 
>>      - 문맥 교환이 필요 없음: 라이브러리가 직접 스케줄링하고 작업에 필요한 정보를 처리하기 때문에 
>> - 단점
>>      - 커널 스레드가 입출력 작업을 위해 대기 상태에 들어가면 모든 사용자 스레드가 같이 대기하게 되는 것 
>>      - 여러 개의 CPU를 동시에 사용할 수 없음 
>>      - 보안에 취약함, 라이브러리에 구현해야 해서 
>> <br>

>> 커널 스레드
>> - 1 to 1 모델
>>      - 커널이 멀티스레드를 지원하는 방식
>>      - 하나의 사용자 스레드가 하나의 커널 스레드와 연결 
>>      - 독립적으로 스케줄링, 대기 상태에 들어가도 다른 스레드는 작업을 계속할 수 있음 
>>      - 멀티 CPU 사용 가능 
>><br>

>> 멀티 스레드
>> - M to N 모델
>>      - 커널 스레드의 개수가 사용자 스레드보다 같거나 작음 
>>      - 하나의 커널 스렐드가 대기 상태에 들어가면 다른 커널 스레드가 대신 작업을 하여 사용자 스레드보다 유연하게 작업을 처리할 수 있음 
>>      - 문맥교환시 오버헤드가 있어 사용자 스레드만큼 빠르지 않음 

<br>

### 결론: 빠르게 움직여야 할때는 사용자 스레드, 안정적으로 움직여야 하는 스레드는 커널 스레드로 작동

<br>

멀티태스킹 vs 멀티스레드
> - 멀티스레드: 하나의 프로세스 내에 여러 개의 스레드를 생성
>   - 스레드: 가벼운 프로세스, 일반 프로세스: 무거운 프로세스

----
## 05 동적 할당 영역과 시스템 호출 
스택 
> - 스레드가 작동하는 동안 추가되거나 삭제되는 동적 할당 영역 

exit(), wait()
exit()
> - 작업이 끝남 
> - 부모 프로세스는 자식 프로세스가 사용하던 자원을 빨리 거둬갈 수 있음 




*의논할 내용*
1. 커널이 무엇인지 
2. 멀티스레드와 멀티프로세싱을 언제 써야 이상적인지... (?)