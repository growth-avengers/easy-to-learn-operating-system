# 스케줄링의 개요
CPU 스케줄러는 프로세스가 생성된 후 종류될 때까지 모든 상태 변화를 조정하는 일입니다.
- 스케줄링은 여러 프로세스의 상황을 고려하여 CPU와 시스템 자원을 어떻게 배정할지 결정하는 일을 말한다.

### 스케줄링의 단계
CPU 스케줄러는 관리의 범주를 나누어 스케줄링을 한다. 
CPU 스케줄링은 규모에 따라 `고수준 스케줄링`, `중간 수준 스케줄링`, `저수준 스케줄링`으로 나눈다.

- 고수준 스케줄링
	- 시스템 내의 전체 작업 수를 조절하는 것을 말한다.
	- 고수준 스케줄링 단계에서는 어떤 작업을 시스템이 받아들일지 또는 거부할지를 결정한다.
	- 고수준 스케줄링에 따라 시스템 내에서 동시에 실행 가능한 프로세스의 총개수를 정한다.
- 저수준 스케줄링
	- 고수준 스케줄링은 수를 조절을 하는 단계라면 저수준 스케줄링은 순서를 미세하게 조절하는 단계이다.
	- 어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 대기 상태로 보낼지를 결정하는 일이다.
- 중간 수준 스케줄링
	- 중간 수준 스케줄링은 고수준 스케줄링과 저수준 스케줄링 사이에 일어나는 스케줄링이다.
	- 중지와 활성화로 전체 시스템의 활성화된 프로세스 수를 조절하여 과부하를 막는다.
	- 프로세스의 상태 중 보류 상태에서 저수준 스케줄링과 원만하게 이루어지도록 완충 역할을 한다.

### 스케줄링의 목적
CPU 스케줄링의 원래 목적은 모든 프로세스가 공평하게 작업하도록 하는 것이다.
- 공평성
	- 모든 프로세스가 자원에 공평하게 배정받아야 한다.
- 효율성
	- 시스템 자원이 유휴 시간 없이 사용되도록 스케줄링을 하고 프로세스의 우선권을 주어야 한다.
- 안정성
	- 우선순위를 사용하여 중요 프로세스가 먼저 작동하도록 배정한다.
- 확장성
	- 프로세스가 증가해도 시스템이 안정적으로 작동하도록 조치한다.

# 스케줄링 시 고려 사항
- CPU 스케줄러가 어떤 프로세스에 우선적으로 CPU를 할당할지 결정할 때 고려해야 할 사항이 있습니다.

### 선점형 스케줄링과 비선점형 스케줄링
- 선점형 스케줄링
	- 어떤 프로세스가 CPU를 할당받아 실행 중이라도 운영체제가 CPU를 강제로 빼앗을 수 있는 스케줄링 방식이다.
- 비선점형 스케줄링
	- 어떤 프로세스가 CPU를 점유하면 다른 프로세스가 이를 빼앗을 수 없는 스케줄링 방식이다.

선점형 스케줄링에서 운영체제가 필요하다고 판단이 되면 프로세스의 작업을 중단시키고 새로운 작업을 시작할 수 있다.
비선점형 스케줄링에서는 어떤 프로세스가 실행 상태에 들어가 CPU를 사용하면 그 프로세스가 종료되거나 자발적으로 대기 상태에 들어가기 전까지 실행된다.

### 프로세스 우선순위
- 프로세스의 우선순위가 없다는 것은 모든 프로세스의 중요도가 같다.
- 대부분 CPU 스케줄러는 우선순위를 사용한다.
- 프로세스는 크게 커널 프로세스와 일반 프로세스로 나눈다.
- CPU 스케줄러는 각 프로세스에 우선순위를 부여하는데 커널 프로세스의 우선순위가 일반 프로세스보다 높다.
- 프로세스는 생선된 후 준비, 실행, 대기 상태를 거쳐 완료가 된다.
- CPU를 할당받아 실행하는 작업을 CPU 버스트, 입출력 작업을 입출력 버스트라고 한다.
- CPU 집중 프로세스와 입출력 집중 프로세스로 나눠진다.
	- CPU 집중 프로세스은 CPU를 많이 사용하는 프로세스다.
	- 입출력 집중 프로세스은 저장장치에서 데이터를 복사하는 일과 같이 입출력을 많이 사용하는 프로세스다.
- CPU 집중 프로세스와 입출력 프로세스가 같이 있을 때 입출력 집중 프로세스를 먼저 실행 상태로 옮기는 것이 효율적이다.
- 스케줄링을 할 때 입출력 집중 프로세스의 우선순위를 CPU 집중 프로세스보다 높이면 시스템의 효율성이 향상된다.

### 전면 프로세스와 후면 프로세스
- 전면 프로세스는 GUI를 사용하는 운영체제에서 화면의 맨 앞에 놓인 프로세스다.
- 후면 프로세스는 사용자와 상호작용이 없는 프로세스다.
- 전면 프로세스의 우선순위가 후면 프로세스보다 높다. 그만큼 후면 프로세스는 전면 프로세스보다 CPU를 할당받을 확률이 적다.

# 다중 큐

### 준비 상태의 다중 큐
프로세스는 저마다 중요도가 다르며 프로세스의 중요도는 프로세스 제어 블록에 표시된다.
준비 상태의 다중 큐를 나타낸 것이다.
프로세스는 준비 상태에 들어올 때마다 자신의 우선순위에 해당하는 큐의 마지막에 삽입한다.
같은 장치의 입출력을 기다리는 프로세스의 프로세스 제어 블록은 동일한 입출력 큐에 모여 있다.

프로세스의 우선순위를 배정이라는 방식에는 고정 우선순위 방식(`static prioritry`)과 변동 우선순위 방식(`dynamic priority`)이 있다.
- 고정 우선순위 방식
	- 운영체제가 프로세스에 우선순위를 부여하면 프로세스가 끝날 때까지 바뀌지 않는 방식이다.
- 변동 우선순위 방식
	- 프로세스 생성 시 부여받는 우선순위가 프로세스 작업 중간에 변하는 방식이다.

변동 우선순위 방식이 시스템의 효율을 높이는 방식은 다음과 같다.
- 우선순위가 낮은 프로세스 P1이 중요한 자원을 사용하고 있다면, 자원을 독점하여 사용하기 때문에 이 자원을 사용하려는 다른 프로세스는 P1이 작업을 마칠 때까지 기다려야 한다.
- 프로세스의 낮은 우선순위를 높은 우선순위로 바꾸는 것을 반전 우선순위라고 한다.
- 변동 우선순위 방식인 반전 우선순위를 사용하면 시스템의 효율성이 높아진다.

### 대기 상태의 다중 큐
대기 상태에서 다중 큐를 사용한다. 대기 상태는 입출력이 완료되기를 기다리는 프로세스가 모여 있는 곳이다.
시스템의 효율을 높이기 위해 대기 상태에서는 같은 입출력을 요구한 프로세스끼리 모아놓은다.

준비 상태의 다중 큐와 대기 상태의 다중 큐의 차이가 있다.
	- 준비 큐는 한 번에 하나의 프로세스를 꺼내어 CPU를 할당한다.
	- 대기 큐는 여러 개의 프로세스 제어 블록을 동시에 꺼내어 준비 상태로 옮긴다.
	- 임출력이 동시에 끝날 경우 여러 개의 인터럽트가 한꺼번에 처리된다.
	- 동시에 끝나는 인터럽트를 처리하기 위해 인터럽트 벡터(`interrupt vector`)라는 자료 구조를 사용한다.
	- 인터럽트 벡터가 동시에 완료된 입출력 정보와 처리 방법이 담겨 있다.
	- 이 정보에 따라 완료된 프로세스 제어 블록은 모두 준비 상태로 이동한다.

대기 상태의 다중 큐에 있는 프로세스 제어 블록은 큐에 삽입된 순서대로 처리되지만, 일부는 나중에 들어론 프로세스 제어 블록이 먼저 준비 상태로 옮겨 가기도 한다. 

# 스케줄링 알고리즘
스케줄링 알고리즘은 비선점형 알고리즘(`non-preemptive algorism`)과 선점형 알고리즘(`preemptive algorism`)으로 나뉜다.

그 중 시분할 시스템을 고려하여 만들어진 알고리즘은 선점형 알고리즘이다. 어떤 프로세스가 CPU를 할당 받아 실행 중이라도 운영체제가 CPU를 강제로 빼앗을 수 있다.

### 스케줄링 알고리즘의 선택 기준
스케줄링 알고리즘을 파악하려면 평가 기준이 있다. 
- CPU 사용률
- 처리량 
- 대기 시간
- 응답 시간
- 반환 시간
CPU 알고리즘 효율성을 평가 할 때는 사용률과 처리량으로는 파악하기 어려워 대기 시간, 응답 시간, 반환 시간을 통해 계산을 한다.

### FCFS 스케줄링
FCFS(`First Come First Served`) 스케줄링은 준비 큐에 도착한 순서대로 CPU를 할당하는 비선점형 방식으로, 선입선출 스케줄링이다.
이 스케줄링 방식은 큐가 하나라 모든 프로세스 우선순위가 동일하다.

FCFS 스케줄링 알고리즘은 처리 시간이 긴 프로세스가 CPU를 차지하고 있으면 다른 프로세스가 끝날 때까지 기달려야 함으로 효율성이 떨어집니다.
이를 콘보이 효과(`Convoy effect`)라고 합니다.

### SJF 스케줄링
SJF(`Shortest Job First`)스케줄링은 준비 큐에 있는 프로세스 중에서 실행시간이 가장 짧은 작업부터 CPU를 할당하는 비선점형 방식으로, 최단 작업 우선 스케줄링이라고 합니다.

하짐나 SJF 스케줄링은 다음과 같은 이유로 사용하기 어렵다.
- 운영체제가 프로세스의 종료 시간을 정확하게 예측하기 어렵다.
	- 현대 프로세스는 사용자와 상요작용이 빈번히 발생하기 때문에 프로그램 종료 시간을 파악하기 어렵다.
- 공평하지 못하다.
	- 프로세스 P3 같은 긴 작업 시간을 가진 프로세스가 준비 큐에 도착 했지만 프로세스가 길다는 이유로 계속 뒤로 밀린다면 공평성이 떨어진다.

결론적으로 SJF 스케줄링은 프로세스의 종료 시간을 파악하기 어렵고 아사 현상이 일어나기 때문에 잘 사용하지 않는다.

### HRN 스케줄링
HRN(`Highest Responses Ratio Next`)스케줄링은 SJF 스케줄링에서 발생할 수 있는 아사 현상을 해결하기 위해 만들어진 비선점형 알고리즘으로 최고 응답률 우선 스케줄링이라고 합니다.

HRN 스케줄링은 서비스를 받기 위해 기다린 시간과 CPU 사용 시간을 고려하여 스케줄링을 하는 방식이다.
```
우선순위 = (대기 시간 + CPU 사용시간) / CPU 사용시간
```
HRN 스케줄링은 우선순위를 정할 때 대기 시간을 고려함으로써 아사 현상을 완화한다.
스케줄링 방식에 에이징을 구현한다.

HRN 스케줄링은 실행 시간이 짧은 프로세스의 우선순위를 높게 설정하면서도 대기  시간을 고려하여 아사 현상을 완화한다.
하지만 공평성이 위배되어 많이 사용되지 않는다.

### 라운드 로빈 스케줄링
라운드 로빈(`Round Robin`)스케줄링은 한 프로세스가 할당받은 시간(`타임 슬라이스`)동안 작업을 하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 자기 차례를 기다리는 방식이다.

라운드 로빈 스케줄링은 FCFS 스케줄링과 비슷한데 각 프로세스마다 CPU를 사용할 수 있는 최대 시간, 타임 슬라이스가 있다.

라운드 로빈 스케줄링은 우선순위가 적용되지 않은 가장 단순한 선점형 스케줄링 방식이다.

### SRT 우선 스케줄링
SRT(`Shortest Remaining Time`) 스케줄링 SJF 스케줄링과 라운드 로빈 스케줄링을 혼합한 방식으로, 최소 잔류  시간 우선 스케줄링이라고 한다.

SJF 스케줄링과 SRT 스케줄링의 평균 대기 시간을 비교하보면서 SRT 스케줄링의 평균 대기 시간이 짧다. 그렇다고 좋은 알고리즘은 아니다.

운영체제가 프로세스의 종료 시간을 예측하기 어렵고 아사 현상이 일어나기 때문에 잘 사용되지 않는다.

### 우선순위 스케줄링
프로세스 중요도에 따라 우선순위(`Priority`)를 갖는데 우선순위를 반영한 스케줄링 알고리즘 스케줄링이다.

우선순위 스케줄리은 선점형 혹은 비선점형 방식으로 구현이 가능하다.
우선순위 알고리즘은 고정 우선순위 알고리즘과 변동 우선순위으로 나뉜다.
- 고정 우선순위 알고리즘
- 변동 우선순위 알고리
프로세스의 우선순위는 시스템의 효율성이 아니라 프로세스 중요도 기준으로 결정된다.

### 다단계 큐 스케줄링
다단계 큐(`multilevel queue`) 스케줄링은 우선순위 따라 준비 큐를 여러 개 사용하는 방식이다.
프로세스는 운영체제로부터 부여받은 우선순위에 따라 우선순위의 큐에 삽입된다.

다단계 큐 스케줄링은 우선순위에 따라 다양한 스케줄링이 가능한 선점형 방식이다.
우선순위가 높은 프로세스 때문에 우선순위가 낮은 프로세스의 작업이 연기되는데, 이러한 문제를 해결하기 위해 제안된 것이 다단계 피드백 큐 스케줄링이다.

### 다단계 피드백 큐 스케줄링
다단계 피드백 큐(`multilevel feedback queue`) 스케줄링은 우선순위가 낮은 프로세스에 불리한 다단계 큐 스케줄링의 문제점을 보안한 방식이다.

다단계 피드백 큐 스케줄링은 프로세스가 CPU를 한 번씩 할당받은 실행될 때마다 프로세스의 우선순위를 낮춤으로써, 다단계 큐에서 우선순위가 낮은 프로세스의 실행이 연기되는 문제를 완화한다.

다단계 피드백 큐 스케줄링은 오늘날 운영체제가 CPU 스케줄링을 위해 일반적으로 사용하는 방식이다. 변동 우선순위 알고리즘의 전형적인 예이다.

# 인터럽트 처리
오늘날의 운영체제는 입출력 시 인터럽트를 이용하여 시스템의 효율을 높인다.

### 인터럽트의 개념
인터럽트 처리는 입출력뿐만 아니라 시스템을 보호하는 데 매우 중요한 작업이다.

### 동기적 인터럽트와 비동기적 인터럽트
인터럽트는 프로세스가 실행중인 명령어로 인해 발생하는 동기적 인터럽트와 실행과 무관하게 발생하는 비동기적 인터럽트로 나뉜다.
- 동기적 인터럽트
	- 프로그램상의 문제 때문에 발생하는 인터럽트
	- 컴퓨터 작업자가 의도적으로 프로세스를 중단하기 위해 발생하는 인터럽트
	- 입출력장치 같은 주변장치의 조작에 의해 인터럽트
	- 산술 연산 중 발생하는 인터럽트
- 비동기적 인터럽트
	- 하드디스크 읽기 오류, 메모리 불량과 같은 하드웨어적인 오류로 발생하는 인터럽트

### 인터럽트 처리 과정
시스템에 많은 인터럽트가 존재하고 고유 번호가 있다. 윈도우에서 이 번호를 IRO라고 하며 시스템에 인터럽트가 발생하면 IRO로 인터럽트를 식별한다.

### 인터럽트와 이중 모드
프로세스는 커널 프로세스와 사용자 프로세스로 나뉜다.
운영체제와 관련 커널 프로세스가 실행되는 상태를 커널 모드이다.
사용자 프로세스가 실행되는 상태를 사용자 모드 라고 한다.

운영체제가 두 모드를 전환하며 일 처리를 하는 것을 이중 모드라고 한다.
이중 모드는 운영체제가 자원을 보호가기 위해 사용하는 기법이다
시스템 호출을 사용하기 위해 운영체제 API를 제공한다.

## 의논할 내용

- 선점형 스케줄링과 비선점형 스케줄링에 대해서 무슨 차이가 있는지

- 타임 슬라이스의 크기와 문맥 교환의 관계
